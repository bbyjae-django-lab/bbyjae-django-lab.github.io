<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Jumbl</title>
  <!-- Lato (700/900) -->
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@700;900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #f7f7f8;
      --fg: #111;
      --muted: #6a6a6a;
      --tile: #fff;
      --tile-border: #d9d9de;
      --tile-locked: #e6f0ff;
      --accent: #2b7cff;
      --accent-weak:#e9f1ff;
      --danger: #ff4d4f;
      --life-on:#111;
      --life-off:#c8c8cf;
      --btn:#111;
      --btn-fg:#fff;
      --shadow: 0 6px 16px rgba(0,0,0,0.08);
    }
    [data-theme="dark"]{
      --bg: #0e0f12;
      --fg: #f2f3f5;
      --muted: #9aa0a6;
      --tile: #17181c;
      --tile-border: #2a2d34;
      --tile-locked: #172235;
      --accent: #7aa6ff;
      --accent-weak:#0f1a2b;
      --danger: #ff6062;
      --life-on:#f2f3f5;
      --life-off:#3a3e46;
      --btn:#f2f3f5;
      --btn-fg:#0e0f12;
      --shadow: 0 8px 18px rgba(0,0,0,0.3);
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family: "Lato", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--fg);
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{
      min-height:100%;
      display:flex;
      flex-direction:column;
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
      gap: 10px;
      max-width: 560px;
      margin: 0 auto;
    }

    header{
      display:flex; align-items:center; justify-content:space-between;
      padding: 6px 4px 2px;
    }
    .title{
      font-weight:900; letter-spacing:0.5px; font-size: 22px;
    }

    /* Theme switch (single icon in knob) */
    .theme{
      --w: 56px; --h: 28px; --pad: 3px;
      width: var(--w); height: var(--h); border-radius: 999px; position: relative;
      background: var(--tile); border:1px solid var(--tile-border); box-shadow: var(--shadow);
      cursor: pointer; display:flex; align-items:center; padding: var(--pad);
      touch-action: manipulation;
    }
    .theme .knob{
      width: calc(var(--h) - var(--pad)*2);
      height: calc(var(--h) - var(--pad)*2);
      border-radius:50%;
      background: linear-gradient(180deg,#fff,#ddd);
      display:grid; place-items:center;
      transform: translateX(0);
      transition: transform 180ms ease;
      overflow:hidden;
    }
    [data-theme="dark"] .theme .knob{ transform: translateX(calc(var(--w) - var(--h))); background: linear-gradient(180deg,#23262d,#1a1d23);}
    .theme .icon{
      width: 16px; height:16px; display:block;
      mask-size: cover; -webkit-mask-size: cover;
      background: #111;
    }
    [data-theme="dark"] .theme .icon{ background:#f2f3f5; }
    /* Sun / Moon via CSS masks (solid shapes) */
    .icon.sun{
      mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g fill="%23000"><circle cx="12" cy="12" r="4"/><path d="M12 1v3M12 20v3M3 12H0M24 12h-3M4.2 4.2l2.1 2.1M17.7 17.7l2.1 2.1M19.8 4.2l-2.1 2.1M6.3 17.7l-2.1 2.1"/></g></svg>') no-repeat 50% 50%;
      -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g fill="%23000"><circle cx="12" cy="12" r="4"/><path d="M12 1v3M12 20v3M3 12H0M24 12h-3M4.2 4.2l2.1 2.1M17.7 17.7l2.1 2.1M19.8 4.2l-2.1 2.1M6.3 17.7l-2.1 2.1"/></g></svg>') no-repeat 50% 50%;
    }
    .icon.moon{
      mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23000" d="M21 13.5A9 9 0 0 1 10.5 3a8 8 0 1 0 10.5 10.5Z"/></svg>') no-repeat 50% 50%;
      -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23000" d="M21 13.5A9 9 0 0 1 10.5 3a8 8 0 1 0 10.5 10.5Z"/></svg>') no-repeat 50% 50%;
    }

    /* Status bar */
    .status{
      display:grid; grid-template-columns: 1fr auto 1fr; align-items:center;
      gap: 8px; padding: 6px 2px 2px;
      font-weight:700; font-size: 14px;
    }
    .lives{ display:flex; gap:8px; align-items:center;}
    .dot{ width:10px; height:10px; border-radius:50%; background: var(--life-on); transform-origin:center; }
    .dot.off{ background: var(--life-off); opacity:0.6; }
    .dot.pop{ animation: pop 340ms ease; }
    @keyframes pop {
      0%{ transform: scale(1); }
      35%{ transform: scale(1.3); }
      60%{ transform: scale(0.85) rotate(-6deg); }
      100%{ transform: scale(0); opacity:0; }
    }

    .mode{
      display:flex; align-items:center; gap:8px; justify-self:center; color: var(--muted);
    }
    .checkbox{
      width:18px; height:18px; border:2px solid var(--muted); border-radius:3px; display:grid; place-items:center; font-size:14px; line-height:0;
      cursor:pointer; user-select:none;
    }
    .checkbox.on{ border-color: var(--accent); color: var(--accent); }
    .timer{ justify-self:end; font-variant-numeric: tabular-nums; }

    /* Board */
    .board{ display:flex; flex-direction:column; gap:12px; margin-top: 8px; }
    .answer{
      display:grid; grid-template-columns: repeat(5, 1fr); gap:10px; padding: 4px;
    }
    .tile{
      aspect-ratio: 1 / 1;
      border: 2px solid var(--tile-border);
      background: var(--tile);
      border-radius: 12px;
      display:grid; place-items:center;
      font-size: clamp(28px, 9vw, 36px);
      font-weight:900;
      letter-spacing: 1px;
      position:relative; overflow:hidden;
      box-shadow: var(--shadow);
    }
    .tile.lock{
      border-color: var(--accent);
      background: linear-gradient(180deg, var(--tile-locked), var(--tile));
    }
    .tile .flash{
      position:absolute; inset:0; background: rgba(127, 159, 255, 0.18);
      opacity:0; transform: scale(0.94);
      pointer-events:none;
    }
    .tile.flash-on .flash{
      animation: flash 180ms ease;
    }
    @keyframes flash{
      from{ opacity:0.5; transform: scale(1); }
      to{ opacity:0; transform: scale(0.92); }
    }

    .row{
      display:grid; grid-template-columns: repeat(5, 1fr); gap:10px; padding: 4px;
      transform-origin:center;
    }
    .row.shake{ animation: shake 300ms ease; }
    @keyframes shake{
      0%,100%{ transform: translateX(0); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
    }

    /* Keys (letter bank) */
    .keys{
      display:grid; grid-template-columns: repeat(5, 1fr); gap: 10px; padding: 4px;
    }
    .key{
      aspect-ratio:1 / 1; border-radius: 12px;
      background: var(--tile); border: 2px solid var(--tile-border);
      display:grid; place-items:center;
      font-weight:900; font-size: clamp(22px, 7.4vw, 28px);
      letter-spacing: 1px;
      cursor:pointer; user-select:none;
      touch-action: manipulation;
      box-shadow: var(--shadow);
      transition: transform 80ms ease, opacity 120ms ease;
    }
    .key:active{ transform: translateY(1px) scale(0.98); }
    .key.used{ opacity: 0.35; filter: saturate(0.4); pointer-events:none; }

    /* Controls */
    .controls{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; padding: 4px; margin-top: 2px;}
    .btn{
      height: 56px; border-radius: 14px; background: var(--btn); color: var(--btn-fg);
      display:grid; place-items:center; font-weight:900; font-size: 16px; letter-spacing:0.4px;
      cursor:pointer; user-select:none; touch-action: manipulation;
      box-shadow: var(--shadow);
      transition: transform 80ms ease, opacity 120ms ease;
    }
    .btn:active{ transform: translateY(1px) scale(0.99); }
    .btn.secondary{ background: var(--tile); color: var(--fg); border: 2px solid var(--tile-border); }

    /* Overlays */
    .overlay{
      position: fixed; inset:0; display:none; place-items:center; padding: 24px;
      background: color-mix(in oklab, var(--bg), rgba(0,0,0,0.6) 30%);
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    .overlay.show{ display:grid; }
    .card{
      width: 100%; max-width: 440px; background: var(--tile); color: var(--fg);
      border: 2px solid var(--tile-border); border-radius: 16px; padding: 20px;
      box-shadow: var(--shadow); text-align:center;
    }
    .card h1{ margin: 8px 0 6px; font-size: 26px; font-weight:900; letter-spacing:0.5px;}
    .card p{ margin: 6px 0 14px; color: var(--muted); font-weight:700; }
    .card .bigbtn{ margin-top:10px; height: 56px; border-radius: 14px; background: var(--btn); color: var(--btn-fg); display:grid; place-items:center; font-weight:900; letter-spacing:0.4px; }

    /* Correct guess animation */
    .tile.success{
      animation: successTile 380ms ease forwards;
    }
    @keyframes successTile{
      0%{ transform: scale(1); opacity:1; }
      70%{ transform: scale(1.22); opacity:0.2; }
      100%{ transform: scale(1.22); opacity:0; }
    }

    /* Timer flash on level split */
    .timer.flash{
      background: var(--accent-weak);
      border-radius: 8px; padding: 2px 6px;
      animation: tf 480ms ease;
    }
    @keyframes tf{ from{ background: var(--accent-weak); } to{ background: transparent; } }

    /* Accessibility targets */
    button, .key, .btn, .theme, .checkbox{ -webkit-touch-callout:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Jumbl</div>
      <div class="theme" id="themeToggle" aria-label="Toggle theme">
        <div class="knob"><i class="icon sun"></i></div>
      </div>
    </header>

    <div class="status">
      <div class="lives" id="lives"></div>

      <div class="mode">
        <div id="hardToggle" class="checkbox" role="checkbox" aria-checked="false" aria-label="hard mode"></div>
        <div>hard mode</div>
      </div>

      <div class="timer" id="timer">00:00</div>
    </div>

    <main class="board" aria-live="polite">
      <div class="answer row" id="answerRow"></div>
      <div class="keys" id="keys"></div>
      <div class="controls">
        <div class="btn secondary" id="backBtn">⌫ Backspace</div>
        <div class="btn" id="shuffleBtn">Shuffle</div>
      </div>
    </main>
  </div>

  <!-- Intro modal -->
  <div class="overlay" id="intro">
    <div class="card">
      <h1>Jumbl</h1>
      <p>Rearrange the letters to spell a 5-letter word. Incorrect guesses cost one life. Lives reset each level, except in hard mode.</p>
      <div class="bigbtn" id="playBtn">Play</div>
    </div>
  </div>

  <!-- Lose modal -->
  <div class="overlay" id="lose">
    <div class="card">
      <h1>no more lives</h1>
      <p id="loseSub">—</p>
      <div class="bigbtn" id="tryAgainBtn">Try again ➜</div>
    </div>
  </div>

  <!-- Stub lists (paste full lists here next iteration) -->
  <script id="answers-json" type="application/json">
    ["APPLE","BRAIN","CHAIR","DRIVE","PLANT","SCALE","CLOUD","MUSIC","ROUTE","NERVE"]
  </script>
  <script id="guesses-json" type="application/json">
    ["APPLE","BRAIN","CHAIR","DRIVE","PLANT","SCALE","CLOUD","MUSIC","ROUTE","NERVE",
     "ALERT","APRON","BRINE","BRINK","CHAIN","CRANE","CRANK","DRANK","RIVED","RULER",
     "PLAIN","PLATE","SCALD","SCARF","CLOUT","CLODS","MUSIC","ROTOR","NURSE","NERVE"]
  </script>

  <script>
    'use strict';

    /*** ---------- Utilities ---------- ***/
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    const shuffle = arr => {
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]];
      }
      return arr;
    };

    const now = () => Date.now();

    /*** ---------- Game State ---------- ***/
    const State = {
      ANSWERS: [],
      ACCEPTED_SET: new Set(),

      answer: "",                 // current answer (string)
      locked: Array(5).fill(null),// null | char (locked right-position letters)
      current: Array(5).fill(""), // transient letters this guess
      filledFromKey: Array(5).fill(null), // which key id filled each slot
      bank: [],                   // array of {id, ch, used}
      lives: 3,
      hardMode: false,
      levelsWon: 0,

      gameStartAt: null,
      levelStartAt: null,
      rafId: null,

      levelGuesses: 0,            // guesses used on current level (for lose modal)
    };

    /*** ---------- DOM Refs ---------- ***/
    const answerRow = $("#answerRow");
    const keysGrid = $("#keys");
    const livesEl = $("#lives");
    const timerEl = $("#timer");
    const intro = $("#intro");
    const lose = $("#lose");
    const loseSub = $("#loseSub");

    /*** ---------- Rendering ---------- ***/
    function renderAnswer() {
      answerRow.innerHTML = "";
      for(let i=0;i<5;i++){
        const t = document.createElement("div");
        t.className = "tile" + (State.locked[i] ? " lock" : "");
        t.setAttribute("data-idx", i);
        const letter = State.locked[i] || State.current[i] || "";
        t.textContent = letter;
        const flash = document.createElement("div");
        flash.className = "flash";
        t.appendChild(flash);
        answerRow.appendChild(t);
      }
    }

    function renderKeys() {
      keysGrid.innerHTML = "";
      for(const k of State.bank){
        const b = document.createElement("button");
        b.className = "key" + (k.used ? " used":"");
        b.textContent = k.ch;
        b.type = "button";
        b.dataset.id = String(k.id);
        b.addEventListener("click", onKeyPress);
        keysGrid.appendChild(b);
      }
    }

    function setupLives(){
      livesEl.innerHTML = "";
      for(let i=1;i<=3;i++){
        const d = document.createElement("div");
        d.className = "dot" + (i<=State.lives ? "" : " off");
        d.dataset.index = i;
        livesEl.appendChild(d);
      }
    }

    function flashTile(idx){
      const tile = answerRow.children[idx];
      if(!tile) return;
      tile.classList.remove("flash-on");
      // force reflow
      void tile.offsetWidth;
      tile.classList.add("flash-on");
      setTimeout(()=> tile.classList.remove("flash-on"), 200);
    }

    function successAnimationThenNext(){
      // animate each tile
      for(let i=0;i<5;i++){
        const tile = answerRow.children[i];
        if(tile){ tile.classList.add("success"); }
      }
      // brief pause then next
      setTimeout(()=>{
        State.levelsWon++;
        flashSplit(levelSeconds());
        resetLevelForNext();
      }, 450);
    }

    function rowShake(){
      answerRow.classList.remove("shake");
      void answerRow.offsetWidth;
      answerRow.classList.add("shake");
      setTimeout(()=>answerRow.classList.remove("shake"), 320);
    }

    function timerFormat(ms){
      const total = Math.floor(ms/1000);
      const h = Math.floor(total/3600);
      const m = Math.floor((total%3600)/60);
      const s = total%60;
      if(h>0) return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function tick(){
      if(!State.gameStartAt){ timerEl.textContent = "00:00"; return; }
      timerEl.textContent = timerFormat(now()-State.gameStartAt);
      State.rafId = requestAnimationFrame(tick);
    }

    function startTimer(){
      if(State.rafId) cancelAnimationFrame(State.rafId);
      State.rafId = requestAnimationFrame(tick);
    }

    function stopTimer(){
      if(State.rafId) cancelAnimationFrame(State.rafId);
      State.rafId = null;
    }

    function levelSeconds(){
      if(!State.levelStartAt) return 0;
      return Math.round((now()-State.levelStartAt)/1000);
    }

    function flashSplit(){
      timerEl.classList.add("flash");
      setTimeout(()=>timerEl.classList.remove("flash"), 480);
    }

    /*** ---------- Key / Input Logic ---------- ***/
    function nextOpenSlot(){
      for(let i=0;i<5;i++){
        if(State.locked[i]) continue;
        if(!State.current[i]) return i;
      }
      return -1;
    }

    function onKeyPress(e){
      const id = Number(e.currentTarget.dataset.id);
      const k = State.bank.find(x=>x.id===id);
      if(!k || k.used) return;

      const idx = nextOpenSlot();
      if(idx===-1) return; // row full

      State.current[idx] = k.ch;
      State.filledFromKey[idx] = id;
      k.used = true;

      renderAnswer(); // refresh tiles text
      renderKeys();   // refresh used state
      flashTile(idx);

      maybeAutoSubmit();
    }

    function backspace(){
      // remove last entered non-locked slot
      for(let i=4;i>=0;i--){
        if(State.locked[i]) continue;
        if(State.current[i]){
          // free key
          const keyId = State.filledFromKey[i];
          if(keyId!==null){
            const k = State.bank.find(x=>x.id===keyId);
            if(k) k.used = false;
          }
          State.current[i] = "";
          State.filledFromKey[i] = null;
          renderAnswer();
          renderKeys();
          break;
        }
      }
    }

    function shuffleBank(){
      // keep items (and their used flags), just reorder
      const arr = State.bank.slice();
      shuffle(arr);
      State.bank = arr;
      renderKeys();
    }

    function rowComplete(){
      for(let i=0;i<5;i++){
        if(!(State.locked[i] || State.current[i])) return false;
      }
      return true;
    }

    function buildGuess(){
      let g = "";
      for(let i=0;i<5;i++){
        g += (State.locked[i] || State.current[i] || " ");
      }
      return g;
    }

    function evaluateGuess(guess, answer){
      // returns array of 'good'|'bad' by index (position match only)
      const out = Array(5).fill("bad");
      for(let i=0;i<5;i++){
        if(guess[i]===answer[i]) out[i]="good";
      }
      return out;
    }

    function markLocked(pattern, guess){
      for(let i=0;i<5;i++){
        if(pattern[i]==="good"){
          State.locked[i] = guess[i];
        }
      }
    }

    function clearTransient(){
      for(let i=0;i<5;i++){
        if(!State.locked[i]){
          // free used key for this slot
          const keyId = State.filledFromKey[i];
          if(keyId!==null){
            const k = State.bank.find(x=>x.id===keyId);
            if(k) k.used = false;
          }
          State.current[i] = "";
          State.filledFromKey[i] = null;
        }
      }
      renderAnswer();
      renderKeys();
    }

    function loseLife(){
      if(State.lives<=0) return;
      // find rightmost active life dot
      const activeIdx = State.lives;
      const dot = livesEl.querySelector(`.dot[data-index="${activeIdx}"]`);
      if(dot){
        dot.classList.add("pop");
        setTimeout(()=>{
          dot.classList.remove("pop");
          dot.classList.add("off");
        }, 340);
      }
      State.lives--;
      if(State.lives<=0){
        gameOver();
      }
    }

    function maybeAutoSubmit(){
      if(!rowComplete()) return;
      const guess = buildGuess();
      const ans = State.answer;

      // classify
      if(guess===ans){
        State.levelGuesses++;
        // success animation then next level
        successAnimationThenNext();
        return;
      }

      if(State.ACCEPTED_SET.has(guess)){
        State.levelGuesses++;
        // valid but wrong: lock correct positions, decrement life, gentle shake, clear others
        const pattern = evaluateGuess(guess, ans);
        markLocked(pattern, guess);
        renderAnswer();
        answerRow.classList.add("shake");
        setTimeout(()=>answerRow.classList.remove("shake"), 300);
        loseLife();
        clearTransient();
        return;
      }

      // invalid: shake + clear (no life cost)
      rowShake();
      clearTransient();
    }

    /*** ---------- Level/Run Management ---------- ***/
    function seedLetters(){
      const chars = State.answer.split("");
      shuffle(chars);
      // represent bank items with stable ids for backspace tracking across shuffles
      let idCounter = 0;
      State.bank = chars.map(ch => ({ id: idCounter++, ch, used:false }));
    }

    function pickNewAnswer(){
      // for variety: random from list; in next pass you can advance sequentially if you want
      State.answer = State.ANSWERS[Math.floor(Math.random()*State.ANSWERS.length)];
    }

    function resetLevelForNext(){
      pickNewAnswer();
      State.locked = Array(5).fill(null);
      State.current = Array(5).fill("");
      State.filledFromKey = Array(5).fill(null);
      State.levelGuesses = 0;
      if(!State.hardMode){
        State.lives = 3;
      }
      setupLives();
      seedLetters();
      renderAnswer();
      renderKeys();
      State.levelStartAt = now();
    }

    function newRun(showIntro=false){
      State.levelsWon = 0;
      State.lives = 3;
      State.locked = Array(5).fill(null);
      State.current = Array(5).fill("");
      State.filledFromKey = Array(5).fill(null);
      setupLives();
      pickNewAnswer();
      seedLetters();
      renderAnswer();
      renderKeys();
      State.gameStartAt = null; // will start on Play
      State.levelStartAt = null;
      timerEl.textContent = "00:00";
      stopTimer();
      if(showIntro){ intro.classList.add("show"); }
    }

    function gameOver(){
      stopTimer();
      // subtext: "3 guesses • MM:SS • XX levels"
      const guesses = State.levelGuesses || 0;
      const time = timerEl.textContent;
      const levels = State.levelsWon;
      loseSub.textContent = `${guesses} guesses • ${time} • ${levels} levels`;
      lose.classList.add("show");
    }

    /*** ---------- Controls & Toggles ---------- ***/
    $("#backBtn").addEventListener("click", backspace);
    $("#shuffleBtn").addEventListener("click", shuffleBank);

    // Theme toggle
    const themeToggle = $("#themeToggle");
    const knobIcon = themeToggle.querySelector(".icon");
    function setTheme(theme){
      document.documentElement.setAttribute("data-theme", theme);
      knobIcon.className = "icon " + (theme==="light" ? "sun" : "moon");
      try{ localStorage.setItem("jumbl-theme", theme); }catch{}
    }
    themeToggle.addEventListener("click", ()=>{
      const cur = document.documentElement.getAttribute("data-theme") || "light";
      setTheme(cur==="light" ? "dark" : "light");
    });

    // Hard mode toggle (checkbox look, restarts run)
    const hardToggle = $("#hardToggle");
    function renderHard(){
      if(State.hardMode){
        hardToggle.classList.add("on");
        hardToggle.setAttribute("aria-checked","true");
        hardToggle.textContent = "✓";
      }else{
        hardToggle.classList.remove("on");
        hardToggle.setAttribute("aria-checked","false");
        hardToggle.textContent = "";
      }
    }
    hardToggle.addEventListener("click", ()=>{
      State.hardMode = !State.hardMode;
      renderHard();
      // Restart the run when toggled
      newRun(false);
    });

    // Intro / Lose modal buttons
    $("#playBtn").addEventListener("click", ()=>{
      intro.classList.remove("show");
      State.gameStartAt = now();
      State.levelStartAt = now();
      startTimer();
    });
    $("#tryAgainBtn").addEventListener("click", ()=>{
      lose.classList.remove("show");
      newRun(false);
      State.gameStartAt = now();
      State.levelStartAt = now();
      startTimer();
    });

    /*** ---------- Keyboard (optional for dev) ---------- ***/
    window.addEventListener("keydown", (e)=>{
      const k = e.key.toUpperCase();
      if(k==="BACKSPACE"){ e.preventDefault(); backspace(); return; }
      if(k.length===1 && k>="A" && k<="Z"){
        // choose first unused key matching k
        const match = State.bank.find(b=>!b.used && b.ch===k);
        if(match){
          // simulate press
          const btn = keysGrid.querySelector(`.key[data-id="${match.id}"]`);
          if(btn){ btn.click(); }
        }
      }
    });

    /*** ---------- Load Lists, Boot ---------- ***/
    function boot(){
      // theme
      try{
        const saved = localStorage.getItem("jumbl-theme");
        if(saved) setTheme(saved);
        else setTheme("light");
      }catch{ setTheme("light"); }

      // lists
      try{
        const A = JSON.parse($("#answers-json").textContent.trim());
        const G = JSON.parse($("#guesses-json").textContent.trim());
        State.ANSWERS = A;
        State.ACCEPTED_SET = new Set(G.concat(A)); // ensure answers are accepted
      }catch(e){
        console.error("Word list parse error", e);
        State.ANSWERS = ["APPLE"];
        State.ACCEPTED_SET = new Set(["APPLE"]);
      }

      renderHard();
      setupLives();
      renderAnswer();
      renderKeys();

      // start with intro modal visible on first load
      newRun(true);

      /*** ---------- Minimal tests (console) ---------- ***/
      // 1) seed letters are permutation
      const testAns = "APPLE";
      const testChars = testAns.split("").sort().join("");
      State.answer = testAns;
      seedLetters();
      const bankChars = State.bank.map(b=>b.ch).sort().join("");
      console.assert(bankChars===testChars, "Seed letters must be permutation of answer");
      // restore actual
      pickNewAnswer(); seedLetters(); renderKeys();

      // 2) auto-submit triggers when row complete (simulate)
      // (We won't mutate state mid-run; just verify helper)
      console.assert(typeof rowComplete === "function", "rowComplete exists");
    }

    document.addEventListener("DOMContentLoaded", boot);
  </script>
</body>
</html>
