<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Jumbl</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <style>
    :root {
      --bg: #faf7f3;
      --fg: #1a1a1a;
      --muted: #6b6b6b;
      --accent: #6f7cf7;
      --tile: #ffffff;
      --tile-border: #d9d4ce;
      --locked: #c9e9cf;
      --danger: #ff6b6b;
      --ok: #34c759;
      --shadow: 0 6px 24px rgba(0,0,0,.08);
    }
    [data-theme="dark"] {
      --bg: #101214;
      --fg: #e8e8e8;
      --muted: #a8a8a8;
      --accent: #8ea2ff;
      --tile: #171a1d;
      --tile-border: #2a2e32;
      --locked: #21402a;
      --danger: #ff7474;
      --ok: #4cd964;
      --shadow: 0 8px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .app {
      min-height: 100%;
      padding: max(env(safe-area-inset-top), 16px) 16px max(env(safe-area-inset-bottom), 20px);
      display: grid;
      grid-template-rows: auto auto 1fr auto auto;
      gap: 16px;
      max-width: 480px;
      margin: 0 auto;
    }

    /* Header */
    .topbar {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 8px;
    }
    .title {
      grid-column: 1 / -1;
      text-align: center;
      font-weight: 800;
      font-size: clamp(28px, 7vw, 36px);
      letter-spacing: 0.04em;
    }
    .subbar {
      display: contents;
    }
    .left, .right {
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      color: var(--muted);
    }
    .left { justify-self: start; }
    .right { justify-self: end; }
    .lives {
      justify-self: center;
      display: inline-flex;
      gap: 8px;
    }
    .dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: var(--fg);
      opacity: 1;
      transform: translateZ(0);
      transition: opacity .2s ease;
    }
    .dot.lost { opacity: .2; }

    /* Answer row */
    .answer {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      padding-top: 6px;
    }
    .tile {
      aspect-ratio: 1 / 1;
      display: grid;
      place-items: center;
      border-radius: 12px;
      background: var(--tile);
      box-shadow: var(--shadow);
      border: 1px solid var(--tile-border);
      font-weight: 800;
      font-size: clamp(20px, 7vw, 28px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      user-select: none;
      transform: translateZ(0);
    }
    .tile.locked {
      outline: 2px solid var(--ok);
      background: color-mix(in oklab, var(--locked) 55%, transparent);
    }

    /* Letter bank */
    .bank {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin-top: 6px;
    }
    .key {
      min-height: 56px; /* >=44px tap target */
      aspect-ratio: 1 / 1;
      border-radius: 12px;
      background: var(--tile);
      border: 1px solid var(--tile-border);
      box-shadow: var(--shadow);
      font-weight: 800;
      font-size: clamp(18px, 6.5vw, 24px);
      letter-spacing: 0.08em;
      display: grid;
      place-items: center;
      text-transform: uppercase;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform .08s ease, opacity .15s ease;
      will-change: transform;
    }
    .key:active { transform: scale(.96); }
    .key[disabled] { opacity: .32; pointer-events: none; }

    /* Controls */
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 6px;
    }
    .btn {
      min-height: 56px;
      border-radius: 14px;
      border: none;
      background: var(--accent);
      color: white;
      font-weight: 800;
      letter-spacing: .02em;
      font-size: clamp(16px, 4.8vw, 18px);
      box-shadow: var(--shadow);
      cursor: pointer;
      touch-action: manipulation;
      transition: transform .08s ease, opacity .2s ease, filter .2s ease;
    }
    .btn.secondary {
      background: var(--tile);
      color: var(--fg);
      border: 1px solid var(--tile-border);
    }
    .btn:active { transform: translateY(1px) scale(.985); }

    /* Switch row */
    .switchrow {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 2px;
      color: var(--muted);
      font-weight: 600;
    }
    .switch {
      --w: 52px; --h: 30px;
      width: var(--w); height: var(--h);
      border-radius: 999px;
      background: var(--tile);
      border: 1px solid var(--tile-border);
      position: relative;
      box-shadow: var(--shadow) inset;
    }
    .switch input { appearance: none; display: none; }
    .thumb {
      position: absolute; top: 50%; left: 4px;
      width: 24px; height: 24px; border-radius: 50%;
      transform: translate3d(0,-50%,0);
      background: var(--accent);
      transition: transform .2s ease;
    }
    .switch input:checked + .thumb {
      transform: translate3d(24px,-50%,0);
    }

    /* Modals */
    .modal {
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      background: color-mix(in hsl, var(--bg) 60%, rgba(0,0,0,.5));
      padding: 20px;
      z-index: 50;
      backdrop-filter: blur(2px);
    }
    .modal.show { display: flex; }
    .card {
      width: min(520px, 92vw);
      border-radius: 18px;
      background: var(--tile);
      border: 1px solid var(--tile-border);
      box-shadow: var(--shadow);
      padding: 20px 18px;
      text-align: center;
      animation: rise .18s ease both;
    }
    .card h2 { margin: 0 0 6px; font-size: 24px; }
    .card p { margin: 0 0 16px; color: var(--muted); line-height: 1.35; }
    @keyframes rise { from { opacity: 0; transform: translateY(6px)} to { opacity: 1; transform: none } }

    /* Animations */
    .shake {
      animation: shake .18s ease both;
    }
    @keyframes shake {
      10% { transform: translateX(-4px); }
      30% { transform: translateX(4px); }
      50% { transform: translateX(-3px); }
      70% { transform: translateX(3px); }
      90% { transform: translateX(-1px); }
      100% { transform: translateX(0); }
    }
    .correct-pop .tile {
      animation: pop .18s ease both, fade .28s ease .06s both;
    }
    @keyframes pop { from { transform: scale(1)} to { transform: scale(1.2)} }
    @keyframes fade { to { opacity: 0 } }

    /* Helper */
    .hidden { display: none !important; }
    .sr { position: absolute; width: 1px; height:1px; overflow: hidden; clip: rect(0 0 0 0); white-space: nowrap; }
  </style>
</head>
<body>
  <div class="app" id="app" aria-live="polite">
    <header class="topbar">
      <div class="title">Jumbl</div>

      <div class="subbar">
        <div class="left" id="levelLabel">lvl one</div>
        <div class="lives" id="lives">
          <span class="dot"></span><span class="dot"></span><span class="dot"></span>
        </div>
        <div class="right" id="timer">00:00</div>
      </div>
    </header>

    <main>
      <section class="answer" id="answerRow" aria-label="answer row"></section>

      <section class="bank" id="bank" aria-label="letter bank"></section>

      <section class="controls" aria-label="controls">
        <button class="btn secondary" id="backspaceBtn" aria-label="backspace">⌫ backspace</button>
        <button class="btn secondary" id="shuffleBtn" aria-label="shuffle">shuffle</button>
      </section>
    </main>

    <div class="switchrow">
      <span>light</span>
      <label class="switch">
        <input type="checkbox" id="themeToggle" />
        <span class="thumb"></span>
      </label>
      <span>dark</span>
    </div>
  </div>

  <!-- Intro Modal -->
  <div class="modal show" id="introModal" role="dialog" aria-modal="true" aria-labelledby="introH">
    <div class="card">
      <h2 id="introH">how to play</h2>
      <p>Tap the letters to unscramble the 5-letter word. Correct guess → next level. Wrong valid word → lose a life (3 total). Not-a-word → shake (no life lost).</p>
      <p class="hidden" id="loadingMsg">loading word lists…</p>
      <div style="display:grid; gap:10px; grid-template-columns: 1fr;">
        <button class="btn" id="playBtn">play</button>
      </div>
      <p style="margin-top:10px;font-size:12px;" id="sourceHint" class="hidden">Tip: place <code>answers.txt</code> and <code>guesses.txt</code> next to this file (or serve via a local/server). Files should be UPPERCASE, one word per line.</p>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div class="modal" id="gameOverModal" role="dialog" aria-modal="true" aria-labelledby="overH">
    <div class="card">
      <h2 id="overH">no more lives</h2>
      <p id="summaryText">time 00:00 • levels completed 0</p>
      <button class="btn" id="retryBtn">try again ➜</button>
    </div>
  </div>

  <script>
    // -----------------------
    // State (as requested)
    // -----------------------
    let answer = "";                 // current answer (string)
    let locked = ["", "", "", "", ""]; // letters fixed in place
    let current = ["", "", "", "", ""]; // current guess letters (unlocked only)
    let lives = 3;
    let levelsWon = 0;
    let gameStartAt = 0;            // timestamp (ms)
    let timerInterval = null;

    let ANSWERS = [];               // array of candidate answers (strings)
    let ACCEPTED_SET = new Set();   // all valid guess words (uppercase)

    // Extra internal helpers
    let bankLetters = [];           // array of {id, ch} for available taps
    let usedAnswers = new Set();    // to avoid immediate repeats

    // Elements
    const els = {
      answerRow: document.getElementById("answerRow"),
      bank: document.getElementById("bank"),
      lives: document.getElementById("lives"),
      levelLabel: document.getElementById("levelLabel"),
      timer: document.getElementById("timer"),
      backspace: document.getElementById("backspaceBtn"),
      shuffle: document.getElementById("shuffleBtn"),
      intro: document.getElementById("introModal"),
      loadingMsg: document.getElementById("loadingMsg"),
      sourceHint: document.getElementById("sourceHint"),
      play: document.getElementById("playBtn"),
      over: document.getElementById("gameOverModal"),
      summary: document.getElementById("summaryText"),
      retry: document.getElementById("retryBtn"),
      themeToggle: document.getElementById("themeToggle"),
      app: document.getElementById("app")
    };

    // -----------------------------------
    // Setup: theme + load external lists
    // -----------------------------------
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    setTheme(prefersDark ? "dark" : "light");
    els.themeToggle.checked = prefersDark;
    els.themeToggle.addEventListener("change", () => setTheme(els.themeToggle.checked ? "dark" : "light"));

    function setTheme(mode) {
      document.documentElement.setAttribute("data-theme", mode);
      try { localStorage.setItem("jumbl-theme", mode); } catch {}
    }
    try {
      const saved = localStorage.getItem("jumbl-theme");
      if (saved) {
        document.documentElement.setAttribute("data-theme", saved);
        els.themeToggle.checked = saved === "dark";
      }
    } catch {}

    // Load word lists on first paint
    let listsLoaded = false;
    (async function loadLists() {
      els.loadingMsg.classList.remove("hidden");
      try {
        const [ansText, guessText] = await Promise.all([
          fetch("./answers.txt", { cache: "no-store" }).then(r => { if (!r.ok) throw new Error("answers.txt not found"); return r.text(); }),
          fetch("./guesses.txt", { cache: "no-store" }).then(r => { if (!r.ok) throw new Error("guesses.txt not found"); return r.text(); })
        ]);
        const norm = t => t.split(/\r?\n/).map(s => s.trim().toUpperCase()).filter(w => /^[A-Z]{5}$/.test(w));
        const answers = norm(ansText);
        const guesses = norm(guessText);

        // Ensure all answers are accepted
        answers.forEach(w => ACCEPTED_SET.add(w));
        guesses.forEach(w => ACCEPTED_SET.add(w));

        ANSWERS = answers.slice();
        listsLoaded = ANSWERS.length > 0 && ACCEPTED_SET.size > 0;
        if (!listsLoaded) throw new Error("Lists empty");
        els.loadingMsg.classList.add("hidden");
      } catch (err) {
        els.loadingMsg.textContent = "couldn't find word lists";
        els.sourceHint.classList.remove("hidden");
        console.warn("Word list load failed:", err);
      }
    })();

    // -----------------------
    // Public API (functions)
    // -----------------------
    function startGame() {
      if (!listsLoaded) {
        // gentle nudge if lists aren't ready yet
        els.loadingMsg.textContent = "loading word lists…";
        els.sourceHint.classList.remove("hidden");
        return;
      }
      lives = 3;
      levelsWon = 0;
      usedAnswers.clear();
      gameStartAt = Date.now();
      resetTimer();
      nextWord();
      renderUI();
      hideIntro();
    }

    function renderUI() {
      // Lives
      els.lives.innerHTML = "";
      for (let i = 0; i < 3; i++) {
        const d = document.createElement("span");
        d.className = "dot" + (i >= lives ? " lost" : "");
        els.lives.appendChild(d);
      }
      // Level label
      els.levelLabel.textContent = "lvl " + numberToWords(Math.max(1, levelsWon + 1));

      // Answer row tiles
      els.answerRow.innerHTML = "";
      for (let i = 0; i < 5; i++) {
        const t = document.createElement("div");
        const lockedHere = !!locked[i];
        t.className = "tile" + (lockedHere ? " locked" : "");
        t.textContent = (locked[i] || current[i] || " ");
        els.answerRow.appendChild(t);
      }

      // Bank keys
      els.bank.innerHTML = "";
      bankLetters.forEach(({ id, ch }) => {
        const b = document.createElement("button");
        b.className = "key";
        b.textContent = ch;
        b.setAttribute("data-id", id);
        b.addEventListener("click", () => handleLetterTapById(id));
        els.bank.appendChild(b);
      });
    }

    function handleLetterTap(letter) {
      // (not used directly — we track by unique id to handle repeats)
    }
    function handleLetterTapById(uid) {
      const idx = bankLetters.findIndex(o => o.id === uid);
      if (idx === -1) return;
      // find next free (unlocked) slot
      const target = nextFreeSlot();
      if (target === -1) return;

      const { ch } = bankLetters[idx];
      current[target] = ch;
      // remove letter from bank
      bankLetters.splice(idx, 1);
      renderUI();
      autoSubmitIfFull();
    }

    function handleBackspace() {
      // clear last non-locked slot that has a letter
      for (let i = 4; i >= 0; i--) {
        if (!locked[i] && current[i]) {
          // return letter to bank
          bankLetters.push({ id: uid(), ch: current[i] });
          current[i] = "";
          break;
        }
      }
      renderUI();
    }

    function shuffleBank() {
      shuffleInPlace(bankLetters);
      renderUI();
    }

    function autoSubmitIfFull() {
      if (current.every((c, i) => c || locked[i])) {
        // Build full guess string from locked+current
        const guess = Array.from({ length: 5 }, (_, i) => locked[i] || current[i]).join("");
        evaluateGuess(guess);
      }
    }

    function lockCorrectLetters(guess) {
      for (let i = 0; i < 5; i++) {
        if (guess[i] === answer[i]) locked[i] = answer[i];
      }
    }

    function gameOver() {
      stopTimer();
      const elapsed = formatMMSS(Math.floor((Date.now() - gameStartAt) / 1000));
      els.summary.textContent = `time ${elapsed} • levels completed ${levelsWon}`;
      els.over.classList.add("show");
    }

    // -----------------------
    // Game mechanics
    // -----------------------
    function nextWord() {
      // pick random unseen answer
      if (usedAnswers.size === ANSWERS.length) usedAnswers.clear();
      let w = "";
      let guard = 0;
      while (!w || usedAnswers.has(w)) {
        w = ANSWERS[(Math.random() * ANSWERS.length) | 0];
        guard++; if (guard > 50) break;
      }
      usedAnswers.add(w);
      answer = w.toUpperCase();
      locked = ["", "", "", "", ""];
      current = ["", "", "", "", ""];
      // seed bank with the 5 letters (by instance)
      bankLetters = answer.split("").map(ch => ({ id: uid(), ch }));
      shuffleInPlace(bankLetters);
      renderUI();
    }

    function evaluateGuess(guess) {
      if (guess === answer) {
        // Correct!
        levelsWon++;
        correctAnimation(() => {
          nextWord();
          renderUI();
        });
        return;
      }
      if (ACCEPTED_SET.has(guess)) {
        // Wrong but valid → lose a life, lock correct positions, clear rest
        lives = Math.max(0, lives - 1);
        lockCorrectLetters(guess);
        // return non-locked letters back to bank
        for (let i = 0; i < 5; i++) {
          if (!locked[i] && current[i]) {
            bankLetters.push({ id: uid(), ch: current[i] });
            current[i] = "";
          }
        }
        shuffleInPlace(bankLetters);
        renderUI();
        if (lives === 0) gameOver();
      } else {
        // Invalid word → shake + clear current (no life lost)
        shakeRow();
        // return all non-locked letters
        for (let i = 0; i < 5; i++) {
          if (!locked[i] && current[i]) {
            bankLetters.push({ id: uid(), ch: current[i] });
            current[i] = "";
          }
        }
        renderUI();
      }
    }

    // -----------------------
    // Timer
    // -----------------------
    function resetTimer() {
      stopTimer();
      updateTimer(); // set to 00:00 immediately
      timerInterval = setInterval(updateTimer, 250);
    }
    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }
    function updateTimer() {
      const elapsed = Math.max(0, Math.floor((Date.now() - gameStartAt) / 1000));
      els.timer.textContent = formatMMSS(elapsed);
    }

    // -----------------------
    // UI helpers / effects
    // -----------------------
    function numberToWords(n) {
      const ones = ["zero","one","two","three","four","five","six","seven","eight","nine","ten",
        "eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"];
      const tens = ["","","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"];
      if (n < 20) return ones[n];
      if (n < 100) return tens[Math.floor(n/10)] + (n%10 ? "-" + ones[n%10] : "");
      if (n < 1000) {
        const h = Math.floor(n/100), r = n%100;
        return ones[h] + " hundred" + (r ? " " + numberToWords(r) : "");
      }
      return String(n);
    }
    function formatMMSS(sec) {
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
    }
    function nextFreeSlot() {
      for (let i = 0; i < 5; i++) if (!locked[i] && !current[i]) return i;
      return -1;
    }
    function uid() {
      return Math.random().toString(36).slice(2, 9) + Date.now().toString(36).slice(-3);
    }
    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
    function shakeRow() {
      els.answerRow.classList.remove("shake");
      void els.answerRow.offsetWidth; // restart animation
      els.answerRow.classList.add("shake");
      setTimeout(() => els.answerRow.classList.remove("shake"), 200);
    }
    function correctAnimation(done) {
      els.answerRow.classList.add("correct-pop");
      setTimeout(() => {
        els.answerRow.classList.remove("correct-pop");
        done && done();
      }, 260);
    }
    function hideIntro() { els.intro.classList.remove("show"); }

    // -----------------------
    // Events
    // -----------------------
    els.play.addEventListener("click", startGame);
    els.retry.addEventListener("click", () => { els.over.classList.remove("show"); startGame(); });
    els.backspace.addEventListener("click", handleBackspace);
    els.shuffle.addEventListener("click", shuffleBank);

    // Accessibility: keyboard (optional on desktop)
    document.addEventListener("keydown", (e) => {
      if (els.intro.classList.contains("show")) return;
      const k = e.key.toUpperCase();
      if (/^[A-Z]$/.test(k)) {
        // find a matching letter in bank
        const idx = bankLetters.findIndex(o => o.ch === k);
        if (idx !== -1) handleLetterTapById(bankLetters[idx].id);
      } else if (e.key === "Backspace") {
        handleBackspace();
      }
    });

    // Prevent iOS double-tap zoom on buttons
    document.addEventListener("gesturestart", e => e.preventDefault());

    // In case the user opens before lists fetch completes, keep play enabled but hint if missing
    if (!listsLoaded) {
      els.sourceHint.classList.add("hidden");
    }
  </script>
</body>
</html>
